Для работы с докерфайлом (чтобы было что запускать) была взята одна из лабораторных работ по предмету "Программирование" (1 курс), в которой нужно было реализовать консольную игру "Жизнь".

```
Правила игры «Жизнь» достаточно простые:

- «Жизнь» разыгрывается на бесконечном обновляемом клеточном поле.
- У каждой клетки 8 соседних клеток.
- В каждой клетке может жить существо.
- Существо с двумя или тремя соседями выживает в следующем поколении, иначе погибает от одиночества или перенаселённости.
- В пустой клетке с тремя соседями в следующем поколении рождается существо.
- Живое существо обозначается ♘, мёртвое - ♞.
```
Начиная лабораторную работу, я написала докерфайл "как знала" из курса информатики (1 сем), просто чтобы вспомнить работу с докером. На самом деле, он получился чем-то средним между идеальным докерфайлом и очень плохим (но я этого еще не знала до того, как начала читать про best practices). Итак, он выглядел таким образом:
```
FROM python:3.9-slim

WORKDIR /app
COPY . .

RUN pip install -r requirements.txt

CMD ["python", "life_console.py"]
```
В целом, неплохо, но есть некоторые нюансы:
- не был написан .dockerignore и например файл с тестами для функций тоже копировался, а он очевидно не нужен
- по  сути нет кэширования в части requirements.txt, то есть мы вначале копируем абсолютно все файлы и если какой-то из них будет изменен (без изменения нужных бибилиотек), то часть 
```
pip install -r requirements.txt
```
будет опять занимать дополнительное время для скачивания

Сам контейнер запускался и работал без проблем
"фотки"
Но давайте сделаем этот докерфайл еще хуже!

1. Возьмем самый широкий и тяжелый образ с кучей ненужных зависимостей (зато не ubuntu✨). Выбор не того базового образа может отнять лишнюю память, занять больше времени при загрузке и вызвать конфликт зависимостей
```
FROM python:latest
```
2. Пропишем передачу всех прав юзеру (хотя это есть по умолчанию). Передача всех прав грозит тем, что пользователю будет доступно чтение, запись, удаление и тп того, что ему в принципе трогать нельзя
```
USER root
```
3. Не будем делать отдельную рабочую директорию, в которую скопируются нужные папки, а поставим все в корень. Это плохо тем, что может вызвать конфликт имен, а также плохой изоляцией файлов программы от системных файлов
```
WORKDIR /
```
4. Копируем все (напомню, .dockerignore нет). Ненужные файлы (в моем случае всякие readme.md, юнит-тесты) занимают память. Также это плохо тем, что по факту мы поставили часто изменяемую инструкцию раньше других (представим, что мы решили изменить какую-нибудь строчку кода, при этом библиотеки остались теми же). Таким образом кэширование на этом месте ломается и следующие инструкции будут создавать новые слои, даже если они были в кэше
```
COPY . .
```
5. Наслаиваем скачивания не особо нужных нам библиотек, увеличивая размер образа и время сборки
```
RUN pip install pygame
RUN pip install windows-curse
```
6. Наконец пишем команды
```
CMD ["python", "life_console.py"]
```

Теперь попробуем запустить постройку образа командой 
```
docker build -f Dockerfile.bad -t life-game:bad .
```
Здесь мы явно указываем сборку именно плохого докерфайла (Dockerfile.bad), а также указываем тэг образа .bad
Запускаем сборку
"фото"
Копирование прошло успешно, но затем на этапе попытки скачать бибилотеки (а конкретно pygame) произошла ошибка, связанная c sdl2-config
"фото"
Интернет подсказывал, что это было связано с отсутсвием каких-то зависимостей и версиями питона
Тут как раз наш образ python:latest и помешал, потому что в самой последней версии нет sdl2-config
Исправим это, взяв другой образ
```
FROM python:3.9-slim
```
pygame скачался
"фото"
но не скачался windows-curse, потому что докер работает на ядре линукса (и curses там встроен в питон), а мы просто так решили вписать в докерфайл бибилотеки, которые посчитали нужными. Уберем его, но для наглядности bad practice внесем, например, pandas. Опять запустим сборку (использую без кэша, чтобы посмотреть на время)
"фото"
Можно увидеть, что ошибок не возникло, да и при скачивании того же образа видно, что он занимает меньше строк 
Сама программа работает 
"фото"
Но например, если бы программа требовала ввода или в зависимостях были уязвимости, то с правами root это было бы небезопасно

Также вспомним, что мы не изолировали копированные файлы, а просто все добавили в root
"фото"
Здесь видно, что директория помимо файлов самой программы содержит еще и системные папки. Это может привести к конфликтам имен, путанице в скриптах или случайному удалению (например, удалению всех логов, а не логов программы)

Теперь напишем хороший докерфайл

Сначала я написала .dockerignore
```
$ notepad .dockerignore &

```
```
/.idea
/.mypy_cache
/_pychache_
glider.txt
grid.txt
life_gui.py
life_proto.py
README.md
```
а потом перешла к докерфайлу
```
$ notepad Dockerfile.good &

```
1. Подходящий базовый образ у нас уже был взят в предыдущих пунктах
```
FROM python:3.9-slim
```
2. Далее мы создаем обычного юзера (UID 2000) и называем его appuser
```
RUN useradd -u 2000 -m appuser
```
3. Изолируем файлы программы в папку /app
```WORKDIR /app
```
4. Тут я взяла requirements.txt (вместо ручного вписывания всех библиотек) и скопируем для начала только их в рабочую директорию, а потом скачаем. 
```
COPY requirements.txt .
RUN pip install -r requirements.txt
```
5. Теперь копируем файлы только с программным кодом (по принципу "часто изменяемые инструкции в самый конец") и от имени appuser запускаем программу (не раньше, так как инсталляция требует root прав)
```
COPY . . 

USER appuser

CMD ["python", "life_console.py"]
```
Сборка успешная с первого раза
"фотки"
А теперь запустим
"фотки"
все так же работает

Рабочая директория содержит только то, что надо
"фотки"
Ну и хорошая версия даже весит чуть меньше плохой
"фотки"

Основные выводы:
- брать нужный базовый образ, а не только самый latest
- следить за правами юзера
- изолировать рабочие файлы в отдельную директорию
- писать .dockerignore (не совсем по части докерфайла, но все же уменьшает размер образа)
- не делать лишних слоев. В моем случае я просто использовала requirements.txt, но также можно просто писать через &
- использовать кэширование оптимально - ставить наиболее часто меняющиеся инструкции в конец 

Плохие практики по работе с контейнерами:

1. Запускать в одном контейнере более 1 процесса
Контейнер создан для решения одной конкретной задачи — будь то веб-сервер, база данных или фоновый процесс. Когда происходит попытка запихнуть в него несколько разных служб, всё начинает ломаться: сложно отслеживать, что происходит, трудно обновлять компоненты по отдельности, а логи превращаются в мешанину. 

2. Хранить данные в контейнере
Контейнер можно удалить, заменить, остановить и т.д. Все данные должны храниться в отдельном надёжном месте (например, на диске), чтобы, например, при смене версии ничего не было утеряно. 